# Homework 0  作业报告 by 76-朱雨田

## 1_BasicDArray

​	作业内容为动态数组的简单封装。BasicDArray 的实现为每当遇到需要扩大数组的操作时，就重新申请一块需要的内存，将原有内容复制进新的内存里，释放原有内存，再做相应更改。

​	数组整体以面向对象的思路实现；数组功能的封装通过重载运算符 `[]` `=` 实现，而申请内存和释放内存采用了C++的 `new` `delete` 关键字。以上任务实现了从面向过程的 C 语言至面向对象的 C++ 语言的平滑思维过渡。

​	注意到 `PushBack` 操作需要复制一遍数组内所有的元素，因此复杂度为 $\text {O}(n)$，以 `PushBack` 初始化整个数组的复杂度则达到了 $\text{O}(n^2)$ 。这样的动态数组操作造成的效率损失远远不能让我们满意。因此，我们考虑设计优化的方法。

## 2_EfficientDArray

​	在 BasicDArray 中，我们可以注意到对效率影响最大的是每次扩展数组的时候伴随的内存复制。因此， EfficientDArray 优化的思路自然是尽量减少内存复制的次数。如果我们每次扩展数组的时候额外多开一些空间，自然就能减少内存复制的次数。在这里我们接触到了以时间换取空间的优化思想。

​	考虑每次扩展数组的时候都将数组扩展一倍。这样，数组中“未用到”的预留空间总不会超过已用到的空间，空间复杂度仅仅是带上了一个常数，这是很令人满意的结果。

​	同时对时间进行分析，当插入 $2^n$ 个元素时，我们需要扩展 $n$ 次数组大小。由于每次扩展的空间大小以指数数量级增长，因此我们求和可以得出复制元素的次数的数量级也在 $2^n$ 的水平。时间复杂度控制在了和一般数组的插入操作相同的水平——不错，我们可以认为这样的优化很令人满意了。事实上，这似乎就是 C++ STL 中 `vector` 的实现思路。

​	扩展空间时计算所需大小的倍增采用以下两行代码实现：

```cpp
if (m_nMax == 0) m_nMax = 1;
while (m_nMax < nSize) m_nMax *= 2;
```

## 3_TemplateDArray

​	C++ 的特点是面向对象编程和泛型编程。前面我们已经基本接触了面向对象编程，而在 TemplateDArray 中我们将实现泛型编程。

​	泛型实际上就是将类型作为参数，来实现对多种类型都适用的同一函数和同一类。这里模板类和函数的改造比较简单，只需在类和函数前加上 `template<typename T>` 关键字，再把所有以前作为类型的 `double` 改为 `T` 即可。这样，我们就完成了一个 `std::vector` 的基本功能。

​	环境配置方面，这里需要自己新建需要的项目文件。新建文件后，在 `src/CMakeLists.txt` 中加上一行 `add_subdirectory(3_TemplateDArray)`，再在 Visual Studio 中执行 Project > Delete Cache and Reconfigure 操作，代码即可自动高亮，项目也能运行了。

## 4_list_Polynomial

​	本次作业还要求实现一个多项式类，要求实现多项式间的加法、乘法运算。通过该作业，我们可以熟悉 C++ STL 的基本使用，并进一步学习面向对象的编程思想。

​	在该作业中，我们定义了结构体 `Term` 存储多项式中每一项的系数和指数信息，并用 `std::list<Term>` 作为存储多项式的数据结构。在 `list` 的插入删除操作中，我们维护了其中元素指数的单调性，从而便于直接输出。

​	我们首先实现了插入 `Term` 的操作，即在 `list` 中寻找是否有次数相同的项，若有，则对系数相加，否则将这一项直接插入到相应位置。在完成插入操作后，我们用 `compress()` 函数剔除系数为0的项，避免浮点误差的累加，同时也能节省存储空间。

​	有了插入操作后，加减法的操作就很自然了——将一个多项式的每一项逐个插入另一个多项式即可。这个加法是 $\text{O}(n^2)$ 的。因为多项式 `list` 是单调的，所以可以类似归并排序地归并两个多项式，优化至 $\text{O}(n)$ 的水平。不过我没有这样写。~~因为懒~~ （似乎sample里也是直接暴力相加的）

​	乘法的操作也并没有复杂太多，只需要将两个多项式的每一项两两相乘后插入结果多项式即可。

​	该作业还需实现从文件中读取数据的方法。C++ 采用 `fstream` 实现文件读写，与 `iostream` 语法类似而与 C 的语法有许多不同。

​	这里我们还了解到了动态链接库（dll）的思想，编译出来的结果可以被其他程序所用。

## 5_map_Polynomial

​	该作业与上一个作业相似，只是我们采用了 `std::map<int, double>` 作为存储多项式的数据结构。该数据结构能快速地通过所给的键来获取对应的值，可以大幅度优化插入项的查找效率。

​	因此，插入操作可以直接省略为一个语句 `m_Polynomial[deg] = coff;` ，无需额外编写函数了。其他的实现与上一个作业基本相同了。

​	该作业的运行方式是和上一个作业得到的动态链接库一起运行并对比效率。测试一组随机数据结果如下：

```cpp
Test List:
5096x^4288+9620x^4801+10642x^5260+4524x^5314+9751x^5773+4212x^6232+9708x^7837+8040x^7951+8630x^8350+7336x^8464+5258x^8809+6082x^8923+196x^11386+3460x^11500+2176x^11614
150x^2144+139x^2657+133x^3116+100x^5693+98x^5807
-46x^2144-35x^2657+29x^3116+96x^5693+30x^5807
Test Constructor time: 24

Test Map:
5096x^4288+9620x^4801+10642x^5260+4524x^5314+9751x^5773+4212x^6232+9708x^7837+8040x^7951+8630x^8350+7336x^8464+5258x^8809+6082x^8923+196x^11386+3460x^11500+2176x^11614
150x^2144+139x^2657+133x^3116+100x^5693+98x^5807
-46x^2144-35x^2657+29x^3116+96x^5693+30x^5807
Test Constructor time: 6

Test List:
Test Constructor time: 8607

Test Map:
Test Constructor time: 9

Test List:
Test Constructor time: 28810

Test Map:
Test Constructor time: 16
```

​	可以看到因为 `map` 插入项的效率远高于 `list`，因此在数据规模较大时，`map` 的总用时远远低于 `list`。这再次为我们提供了优化程序的经验——优化经常用到的操作对提高数据结构的效率是很有必要的。

## 学习心得

​	这实际上已经是做图形学 Homework 0 的二周目了。在之前已经做过一次 2020 年的图形学作业，因为没人可以问，所以在配置环境上吃了不少苦头。这次有了交流群，相信可以轻松不少。

​	因为之前对 C# 比较熟悉，所以在理解面向对象和泛型思想上并没有太大困难。但我之前对 C++ 的了解仅限于算法竞赛的“C+STL”。大概果然是 C# 的语法糖太多了（？），我在学 C++ 的时候遇到了不少“还需要这样写？？？”“报错信息看不懂”的场合。虽然该写的东西大概多调试一下就能写出来，但代码量经验还不够，还没办法写出自信又漂亮的 C++ 代码。以后还得多啃啃 C++ Primer。

​	配置 CMake 对我来说也是之前从未有过的体验。2020 版的作业中的 CMake 代码里写了大量助教自己的东西，虽然很厉害但完全看不懂（？）当时在配置环境的时候各种挣扎了一下午。2024 版的作业里的 CMake 小清新了很多，终于是我也能看懂的版本了。

​	因为是二周目，所以希望把以后的作业尽量高完成度地完成。对图形学产生兴趣是因为我的编程就是从游戏开发起步的，从 shader 开始接触到计算机图形学这门学科的时候我就开始惊叹于这门“所见即所得”的学科的美妙。虽然我似乎是这届图形学课程中唯一一名大一学生，但我还是希望能稳扎稳打的跟紧大部队，学到扎实有用的图形学知识。